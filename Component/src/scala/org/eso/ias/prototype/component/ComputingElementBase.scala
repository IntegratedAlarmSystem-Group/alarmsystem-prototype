package org.eso.ias.prototype.component

import org.eso.ias.prototype.input.Identifier
import org.eso.ias.prototype.input.HeteroInOut
import org.eso.ias.prototype.input.Validity
import org.eso.ias.prototype.input.AlarmValue
import scala.util.control.NonFatal
import org.eso.ias.prototype.behavior.JavaConverter
import scala.collection.mutable.HashMap
import org.eso.ias.prototype.input.AckState
import org.eso.ias.prototype.behavior.JavaTransfer
import scala.collection.mutable.{Set => MutableSet }
import scala.collection.mutable.{Map => MutableMap }
import org.eso.ias.prototype.input.typedmp.IASTypes
import java.util.Properties

/**
 * The Integrated Alarm System Computing Element (ASCE) 
 * is the basic unit of the IAS. This  base class 
 * allows to implement stackable modifications
 * 
 * @param ident: The unique ID of this Component
 * @param out: The the output generated by this Component
 *             after applying the script to the inputs
 *             It can or cannot be an AlarmValue
 * @param requiredInputs: The IDs of the inputs that this component
 *                        needs to generate the output. The list does not change
 *                        during the life time of the component.
 * @param actualInputs: The list of monitor points in input that generated the actual output
 * @param script: The script that manipulated the inputs and generate the output
 * @param newInputs: the map with the value of the monitor points in input
 *                   received after the last update of the output  
 * @see AlarmSystemComponent, ASCState
 * @author acaproni
 */
abstract class ComputingElementBase (
    ident: Identifier,
    out: HeteroInOut,
    requiredInputs: List[String],
    actualInputs: MutableMap[String,HeteroInOut],
    script: String,
    val newInputs: MutableMap[String, HeteroInOut])
    extends ComputingElementState(ident,out,actualInputs,script) {
  require(requiredInputs!=None && !requiredInputs.isEmpty,"Invalid (empty or null) list of required inputs to the component")
  require(requiredInputs.size==actualInputs.size,"Inconsistent size of lists of inputs")
  
  /**
   * Update the output by running the user provided script/class against the inputs.
   * This is actually the core of the ASCE.
   * 
   * A change of the inputs means a change in at least one of
   * the inputs of the list. 
   * A change, in turn, can be a change  of 
   * - the value (or alarm) 
   * - validity
   * - mode 
   * The change triggers a recalculation of the Validity.
   * 
   * The number of inputs of a ASCE does not change during the
   * life span of a component, what changes are the values,
   * validity or mode of the inputs.
   * 
   * In case of an alarm, being ACK or shelved does not trigger
   * a  recalculation of the output.
   * 
   * The calculation of the input is delegated to the overloaded 
   * #transfer(...) that generated the output by stackable modifications.
   * The method provided here, updates the Validity.
   * 
   * @see transfer(...)
   */
  def transfer(): Unit = {
    
    mixInputs(inputs,newInputs)
    
    // Prepare the list of the inputs by replacing the ones in the 
    // inputs with those in the newInputs
    val immutableMapOfInputs: Map[String, HeteroInOut] = Map.empty++inputs
    
    output = transfer(immutableMapOfInputs,id,output.asInstanceOf[HeteroInOut],System.getProperties)
  }
  
  /**
   * Flush the received inputs into the actual inputs.
   * 
   * @param oldInput: The inputs that generated the old output of the Component
   * @param receivedInputs: the inputs that have been updated since the refresh
   *                        of the output of the component
   */
  private def mixInputs(
      oldInputs: MutableMap[String, HeteroInOut], 
      receivedInputs: MutableMap[String, HeteroInOut] ) = {
    
    val len= inputs.size
    receivedInputs.synchronized {
      receivedInputs.keys.foreach { id => oldInputs(id)=receivedInputs(id) }
      receivedInputs.clear()
    }
    assert(len==inputs.size,"The map of inputs increased!")
  } 
  
  /**
   * Update the output by running the user provided script/class against the inputs
   * by stackable modifications (@see the classes mixed in the {@link AlarmSystemComponent}
   * class)
   * 
   * This method sets the validity of the output from the validity of its inputs.
   * 
   * @param theInputs: The inputs, sorted by their IDs 
   * @param id: the ID of this computing element
   * @param actualOutput: the actual output
   * @param pros: properties to pass to the implementors
   * @return The new output
   */
  def transfer(
      inputs: Map[String, HeteroInOut], 
      id: Identifier,
      actualOutput: HeteroInOut,
      props: Properties) : HeteroInOut = {
    
    val valitiesSet = MutableSet[Validity.Value]()
    for ( monitorPoint <- inputs.values ) valitiesSet += monitorPoint.validity
    val newValidity = Validity.min(valitiesSet.toList) 
    
    output.updateValidity(newValidity).asInstanceOf[HeteroInOut]
  }
  
  override def toString() = {
    val outStr: StringBuilder = new StringBuilder(super.toString())
    outStr.append("\n>ID of inputs<\n")
    outStr.append(requiredInputs.mkString(", "))
    outStr.append("\n>Not yet processed inputs<\n")
    newInputs.synchronized( { outStr.append(newInputs.values.mkString(", "))})
    outStr.toString()
  }
}
