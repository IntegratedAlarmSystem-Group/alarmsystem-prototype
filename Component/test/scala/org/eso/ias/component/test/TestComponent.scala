package org.eso.ias.component.test

import org.scalatest.FlatSpec
import org.eso.ias.prototype.input.Identifier
import org.eso.ias.prototype.component.AlarmSystemComponent
import org.eso.ias.prototype.input.AlarmValue
import org.eso.ias.prototype.input.OperationalMode
import org.eso.ias.prototype.input.Validity
import org.eso.ias.prototype.input.AlarmState
import org.eso.ias.prototype.input.AckState
import org.eso.ias.prototype.input.MonitorPointValue
import org.eso.ias.prototype.input.MonitorPoint

class TestComponent extends FlatSpec {
  // The ID of the output generated by the component
  val outId = new Identifier(Some[String]("OutputId"), None)
  
  // The ID of the DAS where the components runs
  val dasId = new Identifier(Some[String]("DAS-ID"),None)
  
  // The ID of the component to test
  val compId = new Identifier(Some[String]("ComponentId"), Option[Identifier](dasId))
  
  val mpRefreshRate = MonitorPoint.MinRefreshRate+50
  
  val requiredInputIDs = List("ID1", "ID2")
  
  behavior of "A Component"
  
  it must "be correctly initialized" in {
    val output: MonitorPoint[AlarmValue] = MonitorPoint.monitorPoint(
      outId,
      None,
      OperationalMode.Unknown,
      mpRefreshRate,
      Validity.Unreliable)
      
    val comp: AlarmSystemComponent[AlarmValue] = new AlarmSystemComponent(
       compId,
       output,
       requiredInputIDs,
       Nil,
       "")
    
    assert(comp.id==compId)
    assert(comp.inputs.isEmpty)
    assert(comp.output.id==outId)
  }
  
  it must "not allow to shelve a None AlarmValue" in {
    val output: MonitorPoint[AlarmValue] = MonitorPoint.monitorPoint(
      outId,
      None, 
      OperationalMode.Unknown,
      mpRefreshRate,
      Validity.Unreliable)
      
    val comp: AlarmSystemComponent[AlarmValue] = new AlarmSystemComponent(
       compId,
       output,
       requiredInputIDs,
       Nil,
       "");
    assertThrows[IllegalStateException] {
      val shelved = comp.shelve(true);
    }
  }
  
  it must "not allow to shelve a Non-AlarmValue output" in {
    val output: MonitorPoint[Long] = MonitorPoint.monitorPoint(
      outId,
      None, 
      OperationalMode.Unknown,
      mpRefreshRate,
      Validity.Unreliable)
      
    val comp: AlarmSystemComponent[Long] = new AlarmSystemComponent(
       compId,
       output,
       requiredInputIDs,
       Nil,
       "");
    assertThrows[IllegalStateException] {
      val shelved = comp.shelve(true);
    }
  }
  
  it must "shelve AlarmValue output" in {
    val alarmVal = new AlarmValue(AlarmState.Active,false,AckState.Acknowledged)
    val mpVal: Option[MonitorPointValue[AlarmValue]] = Some(new MonitorPointValue[AlarmValue](alarmVal))
    val output: MonitorPoint[AlarmValue] = MonitorPoint.monitorPoint(
      outId,
      mpVal, 
      OperationalMode.Operational,
      mpRefreshRate,
      Validity.Unreliable)
      
    val comp: AlarmSystemComponent[AlarmValue] = new AlarmSystemComponent(
       compId,
       output,
       requiredInputIDs,
       Nil,
       "");
    
    val shelved = comp.shelve(true);
    
    val shelvedVal = shelved.output.actualValue.get.value
    assert(shelvedVal.shelved)
    
  }
  
  it must "not allow to ack a None AlarmValue" in {
    val output: MonitorPoint[AlarmValue] = MonitorPoint.monitorPoint(
      outId,
      None, 
      OperationalMode.Unknown,
      mpRefreshRate,
      Validity.Unreliable)
      
    val comp: AlarmSystemComponent[AlarmValue] = new AlarmSystemComponent(
       compId,
       output,
       requiredInputIDs,
       Nil,
       "");
    assertThrows[IllegalStateException] {
      val acked = comp.ack();
    }
  }
  
  it must "not allow to ack a Non-AlarmValue output" in {
    val output: MonitorPoint[Long] = MonitorPoint.monitorPoint(
      outId,
      None, 
      OperationalMode.Unknown,
      mpRefreshRate,
      Validity.Unreliable)
      
    val comp: AlarmSystemComponent[Long] = new AlarmSystemComponent(
       compId,
       output,
       requiredInputIDs,
       Nil,
       "");
    assertThrows[IllegalStateException] {
      val acked = comp.ack() 
    }
  }
  
  it must "ack an AlarmValue output" in {
    val alarmVal = new AlarmValue(AlarmState.Active,false,AckState.Acknowledged)
    val mpVal: Option[MonitorPointValue[AlarmValue]] = Some(new MonitorPointValue[AlarmValue](alarmVal))
    val output: MonitorPoint[AlarmValue] = MonitorPoint.monitorPoint(
      outId,
      mpVal, 
      OperationalMode.Operational,
      mpRefreshRate,
      Validity.Unreliable)
      
    val comp: AlarmSystemComponent[AlarmValue] = new AlarmSystemComponent(
       compId,
       output,
       requiredInputIDs,
       Nil,
       "");
    
    val acked = comp.ack()
    
    val ackedVal = acked.output.actualValue.get.value
    assert(ackedVal.acknowledgement==AckState.Acknowledged)
    
  }
  
  it must " update the output when input changes" in {
    val alarmVal = new AlarmValue(AlarmState.Active,false,AckState.Acknowledged)
    val mpVal: Option[MonitorPointValue[AlarmValue]] = Some(new MonitorPointValue[AlarmValue](alarmVal))
    val output: MonitorPoint[AlarmValue] = MonitorPoint.monitorPoint(
      outId,
      mpVal, 
      OperationalMode.Operational,
      mpRefreshRate,
      Validity.Unreliable)
     
     // Creates 3 MPs for inputs
    val mp1Id = new Identifier(Some[String]("MP1-ID"),Option[Identifier](dasId))
    val mp1Val = new AlarmValue(AlarmState.Active,false,AckState.Acknowledged)
    val mp1Opt: Option[MonitorPointValue[AlarmValue]] = Some(new MonitorPointValue[AlarmValue](mp1Val))
    val mp1: MonitorPoint[AlarmValue] = MonitorPoint.monitorPoint(
      mp1Id,
      mp1Opt, 
      OperationalMode.Operational,
      mpRefreshRate,
      Validity.Unreliable)
      
    val mp2Id = new Identifier(Some[String]("MP2-ID"),Option[Identifier](dasId))
    val mp2Opt: Option[MonitorPointValue[Long]] = Some(new MonitorPointValue[Long](2L))
    val mp2: MonitorPoint[Long] = MonitorPoint.monitorPoint(
      mp2Id,
      mp2Opt, 
      OperationalMode.StartUp,
      mpRefreshRate,
      Validity.Unreliable)
      
    val mp3Id = new Identifier(Some[String]("MP3-ID"),Option[Identifier](dasId))
    val mp3Opt: Option[MonitorPointValue[Long]] = Some(new MonitorPointValue[Long](5L))
    val mp3: MonitorPoint[Long] = MonitorPoint.monitorPoint(
      mp3Id,
      mp3Opt, 
      OperationalMode.Maintenance,
      mpRefreshRate,
      Validity.Reliable)
     
    val comp: AlarmSystemComponent[AlarmValue] = new AlarmSystemComponent(
       compId,
       output,
       requiredInputIDs,
       Nil,
       "");
    
    val computed= comp.inputChanged(mp1::mp2::mp3::Nil)
  }
  
}