package org.eso.ias.component.test

import org.scalatest.FlatSpec
import org.eso.ias.prototype.input.AlarmValue
import org.eso.ias.prototype.input.HeteroInOut
import org.eso.ias.prototype.input.Identifier
import org.eso.ias.prototype.input.java.OperationalMode
import org.eso.ias.prototype.input.Validity
import org.eso.ias.prototype.component.ComputingElement
import org.eso.ias.prototype.component.ComputingElementBase
import org.eso.ias.prototype.input.java.IASTypes
import scala.collection.mutable.{Map => MutableMap }

class TestTransferFunction extends FlatSpec {
  
  /**
   * Builds a Component with a set of inputs to test the transfer method
   */
  trait CompBuilder {
    
    val numOfInputs = 5
    
    // The ID of the DAS where the components runs
    val dasId = new Identifier(Some[String]("DAS-ID"),None)
    
    // The ID of the component running into the DAS
    val compID = new Identifier(Some[String]("COMP-ID"),Option[Identifier](dasId))
    
    // The refresh rate of the component
    val mpRefreshRate = HeteroInOut.MinRefreshRate+50
    
    // The ID of the output generated by the component
    val outId = new Identifier(Some[String]("OutputId"), None)
    // Build the MP in output
    val alarmVal = new AlarmValue()
    val output: HeteroInOut = HeteroInOut(
      outId,
      mpRefreshRate,
      alarmVal, 
      OperationalMode.OPERATIONAL,
      Validity.Unreliable, IASTypes.ALARM)
      
    // The IDs of the monitor points in input 
    // to pass when building a Component
    val requiredInputIDs = (for (i <- 1 to numOfInputs)  yield ("ID"+i)).toList
    
    // Create numOfInputs MPs
    var i=0 // To create different types of MPs
    val inputsMPs: MutableMap[String, HeteroInOut] = MutableMap[String, HeteroInOut]()
    for (id <- requiredInputIDs) {
      val mpId = new Identifier(Some[String](id),Option[Identifier](compID))
      i=i+1
      val mp = if ((i%2)==0) {
        val mpVal = new AlarmValue()
        HeteroInOut(
          mpId,
          mpRefreshRate,
          mpVal, 
          OperationalMode.OPERATIONAL,
          Validity.Unreliable, IASTypes.ALARM)
      } else {
        val mpVal = 1L
        HeteroInOut(
          mpId,
          mpRefreshRate,
          mpVal, 
          OperationalMode.OPERATIONAL,
          Validity.Unreliable, IASTypes.LONG)
      }
      inputsMPs+=(mp.id.id.get -> mp)
    }
    val comp: ComputingElement = new ComputingElement(
       compID,
       output,
       requiredInputIDs,
       inputsMPs,
       "")
  }
  
  behavior of "The Component transfer function"
  
  it must "set the validity to the lower value" in new CompBuilder {
    // This test checks if the validity is set to Reliable if all the
    // validities have this level
    // At the present, this is the only test we can do with only 2 values for the
    // validity
    val component: ComputingElementBase = comp
    
    val keys=inputsMPs.keys.toList.sorted
    keys.foreach { key  => {
      val changedMP = inputsMPs(key).updateValidity(Validity.Reliable)
          
      component.asInstanceOf[ComputingElement].inputChanged(Some(changedMP))
      
      component.transfer()
      if (key!=keys.last) assert(component.output.validity==Validity.Unreliable)
      else assert(component.output.validity==Validity.Reliable)
      } 
    }
  }
  
}