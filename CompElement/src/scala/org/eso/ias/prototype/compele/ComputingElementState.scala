package org.eso.ias.prototype.compele

import scala.collection.mutable.{Map => MutableMap }
import org.eso.ias.prototype.input.Identifier
import org.eso.ias.prototype.input.HeteroInOut
import org.eso.ias.prototype.utils.ISO8601Helper

/**
 * The state of a Alarm System Computing Element evolving during time.
 * 
 * The state is composed of an output, generated by the
 * script applied to the inputs (i.e. monitor points and/or
 * other alarms).
 * The AlarmSystemComponent change its state when the input changes
 * (for example the value of a monitor point changes) or when the operators 
 * acknowledge or shelve the alarm (if the output is an alarm).
 * 
 * The output of a ASCE is normally an alarm generated by digesting the values
 * of the inputs to the component itself. But sometimes, 
 * the output is a value of a given type (for example an integer) 
 * to implement what we called synthetic parameters. 
 * 
 * Note that objects of this class do not necessarily represent a change of 
 * the output i.e. the alarm been set or cleared. 
 * In fact, an object is created also when one of its input changed even if
 * it did not trigger a change of the output.
 * 
 * Objects of this class are mutable.
 * 
 * The id of the ASCE does not change over time unless the ASCE is relocated.
 * In such case a new ASCE must be built to correctly initialize
 * the classes implementing the transfer function. For the same reason,  
 * if the transfer function, implemented by the user changes, 
 * then a new ASCE must be implemented
 * 
 * @param id: the unique identifier of the ASCE
 * @param output: The output alarm produced applying the script to the inputs
 * @param inputs: The inputs (i.e. monitor points and alarms) of the Component
 * @param transferFunction: The script to update the output depending on the
 *                          values of the inputs.
 */
class ComputingElementState (
    final val id: Identifier,
    var output: HeteroInOut,
    final val inputs: MutableMap[String, HeteroInOut],
    final val transferFunction: String)
{
  require(Option[HeteroInOut](output).isDefined)
  require(Option[Identifier](id).isDefined)
  require(Option[MutableMap[String, HeteroInOut]](inputs).isDefined)
  require(Option[String](transferFunction).isDefined)
  
  /**
   * The point in time when this objects (i.e. the snapshot) has been
   * modified.
   */
  protected[compele] val timestamp = System.currentTimeMillis()
  
  override def toString() = {
    val outStr: StringBuilder = new StringBuilder("State of component ")
    outStr.append(id.toString())
    outStr.append(" build at ")
    outStr.append(ISO8601Helper.getTimestamp(timestamp))
    outStr.append("\n>Output<\n")
    outStr.append(output.toString())
    outStr.append("\n>Inputs<\n")
    for (mp <- inputs) outStr.append(mp.toString())
    outStr.append("\n>Script<\n")
    outStr.append(transferFunction)
    outStr.toString()
  }
}
